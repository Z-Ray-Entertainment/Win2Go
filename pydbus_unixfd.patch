diff -ruN pydbus-0.6.0/pydbus/proxy_method.py pydbus-unixfd/pydbus/proxy_method.py
--- pydbus-0.6.0/pydbus/proxy_method.py	2016-12-18 17:27:02.000000000 +0100
+++ pydbus-unixfd/pydbus/proxy_method.py	2019-03-29 01:21:10.000000000 +0100
@@ -2,6 +2,7 @@
 from .generic import bound_method
 from .identifier import filter_identifier
 from .timeout import timeout_to_glib
+from . import unixfd
 
 try:
 	from inspect import Signature, Parameter
@@ -33,8 +34,8 @@
 		self.__name__ = method.attrib["name"]
 		self.__qualname__ = self._iface_name + "." + self.__name__
 
-		self._inargs  = [(arg.attrib.get("name", ""), arg.attrib["type"]) for arg in method if arg.tag == "arg" and arg.attrib["direction"] == "in"]
-		self._outargs = [arg.attrib["type"] for arg in method if arg.tag == "arg" and arg.attrib["direction"] == "out"]
+		self._inargs  = [(arg.attrib.get("name", ""), arg.attrib["type"]) for arg in method if arg.tag == "arg" and arg.attrib.get("direction", "in") == "in"]
+		self._outargs = [arg.attrib["type"] for arg in method if arg.tag == "arg" and arg.attrib.get("direction", "in") == "out"]
 		self._sinargs  = "(" + "".join(x[1] for x in self._inargs) + ")"
 		self._soutargs = "(" + "".join(self._outargs) + ")"
 
@@ -69,10 +70,23 @@
 				raise TypeError(self.__qualname__ + " got an unexpected keyword argument '{}'".format(kwarg))
 		timeout = kwargs.get("timeout", None)
 
-		ret = instance._bus.con.call_sync(
-			instance._bus_name, instance._path,
-			self._iface_name, self.__name__, GLib.Variant(self._sinargs, args), GLib.VariantType.new(self._soutargs),
-			0, timeout_to_glib(timeout), None).unpack()
+		if unixfd.is_supported(instance._bus.con):
+			fd_list = unixfd.make_fd_list(
+				args,
+				[arg[1] for arg in self._inargs])
+			ret, fd_list = instance._bus.con.call_with_unix_fd_list_sync(
+				instance._bus_name, instance._path,
+				self._iface_name, self.__name__, GLib.Variant(self._sinargs, args), GLib.VariantType.new(self._soutargs),
+				0, timeout_to_glib(timeout), fd_list, None)
+			ret = unixfd.extract(
+				ret.unpack(),
+				self._outargs,
+				fd_list)
+		else:
+			ret = instance._bus.con.call_sync(
+				instance._bus_name, instance._path,
+				self._iface_name, self.__name__, GLib.Variant(self._sinargs, args), GLib.VariantType.new(self._soutargs),
+				0, timeout_to_glib(timeout), None)
 
 		if len(self._outargs) == 0:
 			return None
diff -ruN pydbus-0.6.0/pydbus/proxy_signal.py pydbus-unixfd/pydbus/proxy_signal.py
--- pydbus-0.6.0/pydbus/proxy_signal.py	2016-12-18 17:27:02.000000000 +0100
+++ pydbus-unixfd/pydbus/proxy_signal.py	2019-03-29 01:21:10.000000000 +0100
@@ -32,7 +32,7 @@
 		self.signal = signal
 		self.__name__ = "on" + signal.__name__
 		self.__qualname__ = signal._iface_name + "." + self.__name__
-		self.__doc__ = "Assign a callback to subscribe to the signal. Assing None to unsubscribe. Callback: (" + ", ".join(signal._args) + ")"
+		self.__doc__ = "Assign a callback to subscribe to the signal. Assign None to unsubscribe. Callback: (" + ", ".join(signal._args) + ")"
 
 	def __get__(self, instance, owner):
 		if instance is None:
diff -ruN pydbus-0.6.0/pydbus/registration.py pydbus-unixfd/pydbus/registration.py
--- pydbus-0.6.0/pydbus/registration.py	2016-12-18 17:27:02.000000000 +0100
+++ pydbus-unixfd/pydbus/registration.py	2019-03-29 01:21:10.000000000 +0100
@@ -5,6 +5,7 @@
 from .exitable import ExitableWithAliases
 from functools import partial
 from .method_call_context import MethodCallContext
+from . import unixfd
 import logging
 
 try:
@@ -18,10 +19,12 @@
 	def __init__(self, object, interfaces):
 		self.object = object
 
+		self.inargs = {}
 		self.outargs = {}
 		for iface in interfaces:
 			for method in iface.methods:
 				self.outargs[iface.name + "." + method.name] = [arg.signature for arg in method.out_args]
+				self.inargs[iface.name + "." + method.name] = [arg.signature for arg in method.in_args]
 
 		self.readable_properties = {}
 		self.writable_properties = {}
@@ -54,6 +57,7 @@
 	def call_method(self, connection, sender, object_path, interface_name, method_name, parameters, invocation):
 		try:
 			try:
+				inargs = self.inargs[interface_name + "." + method_name]
 				outargs = self.outargs[interface_name + "." + method_name]
 				method = getattr(self.object, method_name)
 			except KeyError:
@@ -61,12 +65,15 @@
 					if method_name == "Get":
 						method = self.Get
 						outargs = ["v"]
+						inargs = ["ss"]
 					elif method_name == "GetAll":
 						method = self.GetAll
 						outargs = ["a{sv}"]
+						inargs = ["s"]
 					elif method_name == "Set":
 						method = self.Set
 						outargs = []
+						inargs = ["ssv"]
 					else:
 						raise
 				else:
@@ -78,14 +85,23 @@
 			if "dbus_context" in sig.parameters and sig.parameters["dbus_context"].kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY):
 				kwargs["dbus_context"] = MethodCallContext(invocation)
 
+			if unixfd.is_supported(connection):
+				parameters = unixfd.extract(
+					parameters,
+					inargs,
+					invocation.get_message().get_unix_fd_list())
+
 			result = method(*parameters, **kwargs)
 
 			if len(outargs) == 0:
 				invocation.return_value(None)
-			elif len(outargs) == 1:
-				invocation.return_value(GLib.Variant("(" + "".join(outargs) + ")", (result,)))
 			else:
-				invocation.return_value(GLib.Variant("(" + "".join(outargs) + ")", result))
+				if len(outargs) == 1:
+					result = (result, )
+				if unixfd.is_supported(connection):
+					invocation.return_value_with_unix_fd_list(GLib.Variant("(" + "".join(outargs) + ")", result), unixfd.make_fd_list(result, outargs, steal=True))
+				else:
+					invocation.return_value(GLib.Variant("(" + "".join(outargs) + ")", result))
 
 		except Exception as e:
 			logger = logging.getLogger(__name__)
@@ -151,6 +167,5 @@
 
 		node_info = [Gio.DBusNodeInfo.new_for_xml(ni) for ni in node_info]
 		interfaces = sum((ni.interfaces for ni in node_info), [])
-
 		wrapper = ObjectWrapper(object, interfaces)
 		return ObjectRegistration(self, path, interfaces, wrapper, own_wrapper=True)
diff -ruN pydbus-0.6.0/pydbus/unixfd.py pydbus-unixfd/pydbus/unixfd.py
--- pydbus-0.6.0/pydbus/unixfd.py	1970-01-01 01:00:00.000000000 +0100
+++ pydbus-unixfd/pydbus/unixfd.py	2019-03-29 01:21:10.000000000 +0100
@@ -0,0 +1,53 @@
+from gi.repository import Gio
+
+# signature type code
+TYPE_FD = "h"
+
+def is_supported(conn):
+	"""
+	Check if the message bus supports passing of Unix file descriptors.
+	"""
+	return conn.get_capabilities() & Gio.DBusCapabilityFlags.UNIX_FD_PASSING
+
+
+def extract(params, signature, fd_list):
+	"""
+	Extract any file descriptors from a UnixFDList (e.g. after
+	receiving from D-Bus) to a parameter list.
+	Receiver must call os.dup on any fd it decides to keep/use.
+	"""
+	if not fd_list:
+		return params
+	return [fd_list.get(0)
+		if arg == TYPE_FD
+		else val
+		for val, arg
+		in zip(params, signature)]
+
+
+def make_fd_list(params, signature, steal=False):
+	"""
+	Embed any unix file descriptors in a parameter list into a
+	UnixFDList (for D-Bus-dispatch).
+	If steal is true, the responsibility for closing the file
+	descriptors are transferred to the UnixFDList object.
+	If steal is false, the file descriptors will be duplicated
+	and the caller must close the original file descriptors.
+	"""
+	if not any(arg
+		   for arg in signature
+		   if arg == TYPE_FD):
+		return None
+
+	fds = [param
+	       for param, arg
+	       in zip(params, signature)
+	       if arg == TYPE_FD]
+
+	if steal:
+		return Gio.UnixFDList.new_from_array(fds)
+
+	fd_list = Gio.UnixFDList()
+	for fd in fds:
+		fd_list.append(fd)
+	return fd_list
diff -ruN pydbus-0.6.0/README.rst pydbus-unixfd/README.rst
--- pydbus-0.6.0/README.rst	2016-12-18 17:27:02.000000000 +0100
+++ pydbus-unixfd/README.rst	2019-03-29 01:21:10.000000000 +0100
@@ -15,7 +15,7 @@
 * PyGI_ (not packaged on pypi, you need to install it from your distribution's repository - it's usually called python-gi, python-gobject or pygobject)
 * GLib_ 2.46+ and girepository_ 1.46+ (Ubuntu 16.04+) - for object publication support
 
-.. _PyGI: https://wiki.gnome.org/Projects/PyGObject
+.. _PyGI: https://pygobject.readthedocs.io/
 .. _GLib: https://developer.gnome.org/glib/
 .. _girepository: https://wiki.gnome.org/Projects/GObjectIntrospection
 
@@ -46,7 +46,7 @@
 	    print(unit)
 
 Start or stop systemd unit
-~~~~~~~~~~~~~~~~~~
+~~~~~~~~~~~~~~~~~~~~~~~~~~
 .. code-block:: python
 
 	from pydbus import SystemBus
diff -ruN pydbus-0.6.0/tests/run.sh pydbus-unixfd/tests/run.sh
--- pydbus-0.6.0/tests/run.sh	2016-12-18 17:27:02.000000000 +0100
+++ pydbus-unixfd/tests/run.sh	2019-03-29 01:21:10.000000000 +0100
@@ -15,4 +15,5 @@
 	"$PYTHON" $TESTS_DIR/publish.py
 	"$PYTHON" $TESTS_DIR/publish_properties.py
 	"$PYTHON" $TESTS_DIR/publish_multiface.py
+	"$PYTHON" $TESTS_DIR/unixfd.py
 fi
diff -ruN pydbus-0.6.0/tests/unixfd.py pydbus-unixfd/tests/unixfd.py
--- pydbus-0.6.0/tests/unixfd.py	1970-01-01 01:00:00.000000000 +0100
+++ pydbus-unixfd/tests/unixfd.py	2019-03-29 01:21:10.000000000 +0100
@@ -0,0 +1,60 @@
+from pydbus import SessionBus
+from gi.repository import GLib
+from threading import Thread
+import sys
+import os
+
+loop = GLib.MainLoop()
+
+
+with open(__file__) as f:
+	contents = f.read()
+
+
+class TestObject(object):
+	"""
+	<node>
+	<interface name="baz.bar.Foo">
+		<method name="Hello">
+			<arg type="h" name="in_fd" direction="in"/>
+			<arg type="h" name="out_fd" direction="out"/>
+		</method>
+	</interface>
+	</node>
+	"""
+	def Hello(self, in_fd):
+		with os.fdopen(in_fd) as in_file:
+			in_file.seek(0)
+			assert(contents == in_file.read())
+			print("Received fd as in parameter ok")
+		with open(__file__) as out_file:
+			assert(contents == out_file.read())
+			return os.dup(out_file.fileno())
+
+bus = SessionBus()
+
+
+with bus.publish("baz.bar.Foo", TestObject()):
+	remote = bus.get("baz.bar.Foo")
+
+	def thread_func():
+		with open(__file__) as in_file:
+			assert(contents == in_file.read())
+			out_fd = remote.Hello(in_file.fileno())
+			with os.fdopen(out_fd) as out_file:
+				out_file.seek(0)
+				assert(contents == out_file.read())
+				print("Received fd as out argument ok")
+		loop.quit()
+
+	thread = Thread(target=thread_func)
+	thread.daemon = True
+
+	def handle_timeout():
+		exit("ERROR: Timeout.")
+
+	GLib.timeout_add_seconds(2, handle_timeout)
+
+	thread.start()
+	loop.run()
+	thread.join()
